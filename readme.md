<div id="header" align="center">
  <img src="https://media.giphy.com/media/xTiN0IuPQxRqzxodZm/giphy.gif" width="400"/>

<h1>
  Squiz
</hi>
  
</div>

---

## üí≠ What is Squiz?

Squiz is an API that allows to create and solve quizzes. These quizzes can be scheduled and defined to be answered within a specific range of time.
The API was built using the Django framework with help of the Graphene library to support GraphQL queries and mutations. It connects to a MySQL database by using the default ORM interface provided by Django.

## üìÅ Project structure

The API follows the default structure generated by Django, which separates the logic into the following "applications":

- ‚ùì **Quizzes**: Contains all the business logic related to the **main entities of the project**, which are: **quiz, question and option**.
<br>

- üë• **Users**: Contains all the business logic related to the **users** and the registration/authentication process to use the API.
<br>

- üìÖ **Scheduler**: Contains all the business logic related to the global **scheduler** of the app. The scheduler allows to automatically enable and disable quizzes based on their start and end time. It can also execute background time based tasks.


üìÅ In general, these applications share a well defined structure which is composed of the following sub-folders:

- **Migrations**: Contains auto-generated history files about the changes made to the database schema. These changes allow to build the DB in a fresh DBMS by executing the Django command `python3 manage.py migrate` (See more detail in the installation and execution section).

- **Mutators**: Contains the definition of the mutators that will be registered in the app. These mutators are then imported in the main GraphQL schema definition. 

- **Queries**: Similar to the mutators, this folder contains all the definition of the queries that can be used. They are also imported and registered in the main GraphQL schema object.

- **Tests**: This folder contains different tests related to its application.

üì∞ Also, the following files can be found in the applications folders:

- **Jobs**: Defines the jobs that will be added to the scheduler. They expose an `initial_jobs_config` variable containing the different jobs that should be registered. They can be of interval or time based types. The jobs get registered when the application gets executed.

- **Models**: Contains the ORM definition of the tables in the database. The classes allow to interact with the database by using the ORM interface.

- **Schema**: Contains the aggregation of all the queries and mutations of the application. It is a common file that gets imported and added to the core schema definition.

- **Utils**: Contains any kind of utility function related to the application.

- **Validators**: Contains validation functions that will run for specific database attributes when the ORM detects that data is being saved.

‚ÑπÔ∏è For any further information about the default folders and files generated by the Django framework, please take a look at the official documentation.

## üìã Queries and mutations available

To see the list of available mutations and queries import the JSON file `squiz_api_postman_collection` into your Postman app. This file contains the updated list of mutations and queries that the API provides.

**Note**: The Postman requests use global variables for the url and port. Go to the collection settings in case you need to modify them (for example the port when using the production execution).

## ‚öôÔ∏è How to execute the project

### Before following the steps

The API needs a relational database to connect to. No matter if it is empty. You will need the credentials later on.

### üíª Execution in local machine

1. Make sure you have Python 3.9 installed along pip or pip3 to install the required modules. 
<br>

2. Download the project and from the root folder (`/squiz/`) generate a new Python environment. You can create one by using the command: `python<version> -m venv <path_to_virtual_env>`. For example, tu create a virtual environment in the same folder use: `python<version> -m venv <virtual_environment_name>`.
<br>

3. Enable the virtual environment created in the previous step by using one of the following commands: `source <path_to_virtual_env>/bin/activate` (for Linux) or `<path_to_virtual_env>/Scripts/activate` (for Windows).
<br>

4. Once the virtual environment is enabled, you have to install the dependencies of the project, which are inside of the `requirements.txt` file. Use the following command to install them: `pip3 install -r requirements.txt` or `pip install -r requirements.txt`. These commands will download and install the third party modules inside of the virtual environment, so it does not affect your local packages.
<br>

5. Configure the environment variables. Inside `/core/settings.py` you will see that the application gets some environment variables, which are related to the database connection and other main configurations. Copy the following template and create an `.env` file in the root folder containing your credentials. This file will be used once the app starts.

```
SECRET_KEY=...
DEBUG=...
ALLOWED_HOSTS=...

DB_ENGINE=... // See more information in the Django DB documentation: https://docs.djangoproject.com/en/4.2/ref/databases/
DB_NAME=...
DB_USER=...
DB_PASSWORD=...
DB_HOST=...
DB_PORT=...
DB_CHARSET=... 

EMAIL_HOST=...
EMAIL_PORT=...
EMAIL_USER=...
EMAIL_PASSWORD=...
EMAIL_USE_TLS=...
```

6. If the database hasn't been used before, run the command `python3 manage.py migrate` to generate the database schema.
<br>

7. Use the following command to execute the application in development mode: `python3 manage.py runserver`

### üêã Execution using Docker

1. Make sure you have Docker installed correctly in your local machine.
<br>

2. In the root folder you will see two `docker-compose` files, one for a more realistic production environment (`docker-compose.prod.yaml`) and one for development (`docker-compose.dev.yaml`). Each one of them require to have an environment file like step 5 of the previous section. For the production file, `.env.prod` file is expected, while for development is `.env.dev`.

    #### Development execution

    * From the root folder execute the following command, which will build the docker image of the app, create a container and a network in detached mode: `docker-compose -f docker-compose.dev.yaml up -d`.
    <br>

    * If the service was created correctly you will see it in the containers list by using the command `docker ps`.
    <br>

    * The exposed port by default in the `docker-compose` file is `8000`, so the address that you can use to interact with the API will be `localhost:8000`.
    <br>

    * To stop the application and remove the created resources use the following command: `docker-compose -f docker-compose.dev.yaml down`.

    #### Production execution

    * The main difference with the development execution is the command that the container will use. The production one uses Gunicorn to run the application and also starts an Nginx proxy server to handle incoming requests and redirect them to the app. Hence, the exposed port will be different. The app will be accessible using the address `localhost:1337`.
    <br>

    * You can adjust your Nginx configuration and image generation by modifying the config file in the `/nginx` folder.
    <br>

    * From the root folder execute the following command, which will build the docker image of the app, create a container and a network in detached mode: `docker-compose -f docker-compose.prod.yaml up -d`.
    <br>

    * To stop the application and remove the created resources use the following command: `docker-compose -f docker-compose.prod.yaml down`.

## ü•á Credits

This project has been created and developed by **SouthViking** as a personal project.

Feel free to add new features or fix bugs in case you find some. Please open a **pull request** using **your own branch** and don't forget to add me as reviewer! 
